<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.0 on Fri Jan 16 23:50:59 2009 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>ajs_ellipse_plot.pro (Anthony Smith's IDL routines)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="ajs_ellipse_plot.pro (Anthony Smith's IDL routines)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">; Plot an ellipse</span>
<span class="comments">;</span>
<span class="comments">; Wrapper on plot or oplot</span>
<span class="comments">; :Params:</span>
<span class="comments">;    a : in, required</span>
<span class="comments">;       Semimajor/minor x-axis</span>
<span class="comments">;    b : in, required</span>
<span class="comments">;       Semimajor/minor y-axis</span>
<span class="comments">;    xc : in, optional, default=0</span>
<span class="comments">;       x-co-ordinate of centre of ellipse</span>
<span class="comments">;    yc : in, optional, default=0</span>
<span class="comments">;       y-co-ordinate of centre of ellipse</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    ang : in, optional</span>
<span class="comments">;       Positional angle (degrees anticlockwise)</span>
<span class="comments">;    rho : in, optional</span>
<span class="comments">;       Correlation between x and y, with a and b now interpreted as</span>
<span class="comments">;       standard deviation in x and y, to give &lt;n_sigma>-sigma contours</span>
<span class="comments">;</span>
<span class="comments">;       Equivalently, plot an ellipse within a rectangle bounded by xc</span>
<span class="comments">;       +/- a and yc +/- b, where the ellipse touches the rectangle at</span>
<span class="comments">;       +/- (xc + rho * a, yc + b) and +/- (xc + a, yc + rho * b)</span>
<span class="comments">;    n_sigma : in, optional, default=1</span>
<span class="comments">;       With rho, plot &lt;n_sigma>-sigma contour(s) (equivalent to</span>
<span class="comments">;       multiplier on a and b). Can be an array of values</span>
<span class="comments">;    overplot : in, optional</span>
<span class="comments">;       Set /overplot to overplot (uses oplot rather than plot)</span>
<span class="comments">;    plotfile : in, optional</span>
<span class="comments">;       See ajs_plot_start</span>
<span class="comments">;    show_plot : in, optional</span>
<span class="comments">;       See ajs_plot_start</span>
<span class="comments">;    open : in, optional</span>
<span class="comments">;       See ajs_plot_start</span>
<span class="comments">;    close : in, optional</span>
<span class="comments">;       See ajs_plot_start</span>
<span class="comments">;    _REF_EXTRA</span>
<span class="comments">;       Keywords for plot/oplot</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    ajs_ellipse_plot, 1, 1</span>
<span class="comments">;</span>
<span class="comments">;    ajs_ellipse_plot, 2, 3, 10, 20</span>
<span class="comments">;</span>
<span class="comments">;    ajs_ellipse_plot, 4, 1, ang=30</span>
<span class="comments">;</span>
<span class="comments">;    ajs_ellipse_plot, 1, 1, rho=0.8, /overplot</span>
<span class="comments">;</span>
<span class="comments">;    ajs_ellipse_plot, 3, 1, rho=0.5, n_sigma=2</span>
<span class="comments">;</span>
<span class="comments">;    ajs_ellipse_plot, 3, 1, rho=-0.5, n_sigma=[1,3,2]</span>
<span class="comments">; :History:</span>
<span class="comments">;    28 Mar 2008 Written, Anthony Smith</span>
<span class="comments">;-</span>
PRO ajs_ellipse_plot, a, b, xc, yc, ang=ang, rho=rho, overplot=overplot, $
                      n_sigma=n_sigma, plotfile=plotfile, $
                      show_plot=show_plot, open=open, close=close, _REF_EXTRA=e
  compile_opt idl2
  debug = ajs_debug()
  IF debug GE 2 THEN BEGIN 
      message, 'Plotting ellipse', /inf
      message, ajs_kw_string(a=a, b=b, xc=xc, xy=xy, ang=ang, rho=rho, $
                             overplot=overplot, n_sigma=n_sigma, $
                             plotfile=plotfile, show_plot=show_plot, $
                             open=open, close=close), /inf
  ENDIF 

  <span class="comments">;; Setup plot</span>
  eps = keyword_set(open) OR keyword_set(show_plot)
  ajs_plot_start, plotfile=plotfile, eps=eps

  IF NOT keyword_set(close) AND n_elements(a) GT 0 THEN BEGIN 
      <span class="comments">;; Plot &lt;n_sigma>-sigma contours?</span>
      IF n_elements(n_sigma) EQ 0 THEN BEGIN
          <span class="comments">;; Change names so input arrays do not get altered</span>
          c = a
          d = b
      ENDIF ELSE IF n_elements(n_sigma) EQ 1 THEN BEGIN
          c = a * n_sigma
          d = b * n_sigma
      ENDIF ELSE BEGIN
          <span class="comments">;; Loop over different values of n_sigma and then return</span>
          n_sigma_sorted = n_sigma[reverse(sort(n_sigma))]
          
          <span class="comments">;; Optional overplot for first (largest) contour</span>
          IF n_elements(plotfile) GT 0 OR keyword_set(show_plot) THEN $
             open_tmp = 1 $
          ELSE $
             open_tmp = keyword_set(open)
          ajs_ellipse_plot, a, b, xc, yc, ang=ang, rho=rho, $
                            overplot=overplot, $
                            n_sigma=n_sigma_sorted[0], plotfile=plotfile, $
                            open=open_tmp, show_plot=show_plot, _STRICT_EXTRA=e

          <span class="comments">;; Loop over the rest</span>
          FOR i = 1, n_elements(n_sigma) - 1 DO BEGIN
              ajs_ellipse_plot, a, b, xc, yc, ang=ang, rho=rho, /overplot, $
                                n_sigma=n_sigma_sorted[i], open=open_tmp, $
                                _STRICT_EXTRA=e
          ENDFOR
          
          IF n_elements(plotfile) GT 0 AND NOT keyword_set(open) THEN $ 
             ajs_ellipse_plot, plotfile=plotfile, /close, show_plot=show_plot

          <span class="comments">;; Done</span>
          return
      ENDELSE

      <span class="comments">;; Make a circle</span>
      theta = ajs_linspace(0, 360, 181) / !RADEG <span class="comments">; Radians</span>
      x = cos(theta)
      y = sin(theta)
      
      <span class="comments">;; Bounded by a rectangle?</span>
      IF n_elements(rho) GT 0 THEN BEGIN
          <span class="comments">;; Centred on origin, equation for bivariate Gaussian gives</span>
          <span class="comments">;; 1-sigma contour as (ellipse)</span>
          <span class="comments">;; 1 = (1 / (1 - rho^2)) * [ x^2 / sigma_x^2 + y^2 / sigma_y^2 </span>
          <span class="comments">;;                           - 2 rho x y / (sigma_x sigma_y) ]</span>
          <span class="comments">;; Quadratic function => semimajor/minor axes given by eigenvalues</span>
          <span class="comments">;; 1 = e_1 X^2 + e_2 Y^2</span>
          <span class="comments">;; where ellipse is given by   e_1 = 1 / c^2</span>
          <span class="comments">;;                             e_2 = 1 / d^2</span>
          
          <span class="comments">;; E-vals of symm. matrix of above fn, with c = sigma_x, d = sigma_y</span>
          evals = eigenql([[1. / (c ^ 2. * (1. - rho ^ 2.)), $
                            - rho / (c * d * (1. - rho ^ 2.))], $
                           [- rho / (c * d * (1. - rho ^ 2.)), $
                            1. / (d ^ 2. * (1. - rho ^ 2.))]], $
                          eigenvectors=evecs, /double)
          
          <span class="comments">;; Axes of unrotated ellipse (to be rotated later on)</span>
          c = 1. / sqrt(evals[0])
          d = 1. / sqrt(evals[1])
          
          <span class="comments">;; Matrix of eigenvectors will be the rotation matrix => find angle</span>
          ang = atan(evecs[0, 1] / evecs[0, 0]) * !RADEG
          
          <span class="comments">;; Eigenvalues are in descending order, so may need to reverse rot.</span>
          <span class="comments">;; (Seems to work, not sure why!)</span>
          IF rho GT 0 THEN $
             ang = -abs(ang) $
          ELSE $
             ang = abs(ang)
      ENDIF
      
      <span class="comments">;; Change its size</span>
      x = x * c
      y = y * d
      
      <span class="comments">;; Rotate it</span>
      IF n_elements(ang) GT 0 THEN BEGIN 
          x0 = x
          y0 = y
          cosang = cos(ang / !RADEG)
          sinang = sin(ang / !RADEG)
          x = x0 * cosang - y0 * sinang
          y = x0 * sinang + y0 * cosang
      ENDIF 
      
      <span class="comments">;; Shift it</span>
      IF n_elements(xc) GT 0 THEN $
         x = x + xc
      IF n_elements(yc) GT 0 THEN $
         y = y + yc

      <span class="comments">;; Plot it  </span>
      IF keyword_set(overplot) THEN $
         oplot, x, y, _EXTRA=e $
      ELSE $
         plot, x, y, _STRICT_EXTRA=e
  ENDIF

  ajs_plot_stop, plotfile=plotfile, show_plot=show_plot, open=open, close=close
END
</code>
    </div>
  </body>
</html>