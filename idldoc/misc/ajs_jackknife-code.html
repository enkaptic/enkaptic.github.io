<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.0 on Fri Jan 16 23:51:00 2009 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>ajs_jackknife.pro (Anthony Smith's IDL routines)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="ajs_jackknife.pro (Anthony Smith's IDL routines)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">; This function returns the jackknife method-estimated standard</span>
<span class="comments">; deviation (and optionally the jackknife mean) of n resamplings</span>
<span class="comments">; of a quantity, where each of the n estimates of the quantity</span>
<span class="comments">; is generated by removing (1/n) of the original sample data points.</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; This function returns the jackknife method-estimated standard</span>
<span class="comments">; deviation (and optionally the jackknife mean) of n resamplings</span>
<span class="comments">; of a quantity, where each of the n estimates of the quantity</span>
<span class="comments">; is generated by removing (1/n) of the original sample data points.</span>
<span class="comments">; :Returns:</span>
<span class="comments">;    Return value is the jackknife standard deviation or, if</span>
<span class="comments">;    jackknife_estimates is [m, n], returns jackknife covariance matrix [m, m]</span>
<span class="comments">; :Params:</span>
<span class="comments">;    jackknife_estimates : in, required</span>
<span class="comments">;       [n] or [m, n] array of n estimates of a quantity, or n</span>
<span class="comments">;       estimates of m quantities</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    original_estimate : in, optional</span>
<span class="comments">;       Supply this value to get bias correction (see below)</span>
<span class="comments">;    bias_correction : out, optional</span>
<span class="comments">;       Bias-corrected estimate is x_c = x + b where x is the original</span>
<span class="comments">;       estimate and b is the bias_correction</span>
<span class="comments">;    jackknife_mean : out, optional</span>
<span class="comments">;       Mean of the jackknife samples (NB different from</span>
<span class="comments">;       bias-corrected estimate)</span>
<span class="comments">; :History:</span>
<span class="comments">;    24 Jan 2008 Created, Anthony Smith</span>
<span class="comments">;</span>
<span class="comments">;    7 Apr 2008 Added covariance output for [m, n] input</span>
<span class="comments">;-</span>
FUNCTION ajs_jackknife, jackknife_estimates, $
                        original_estimate=original_estimate, $
                        bias_correction=bias_correction, $
                        jackknife_mean=jackknife_mean
  compile_opt idl2
  debug = ajs_debug()
  IF debug GE 2 THEN message, 'Jackknife', /inf

  IF size(reform(jackknife_estimates), /n_dimensions) EQ 1 THEN BEGIN
      IF debug GE 2 THEN message, 'Single array of values', /inf
      n_jack = n_elements(jackknife_estimates)
      <span class="comments">;; Variance returns sum(deviations^2) / (n-1)</span>
      jackknife_std = sqrt((n_jack - 1.) * variance(jackknife_estimates) $
                           * (n_jack - 1.) / n_jack)
      
      IF arg_present(jackknife_mean) THEN $
         jackknife_mean = mean(jackknife_estimates)
      
      IF arg_present(bias_correction) $
         AND n_elements(original_estimate) GT 0 THEN $
            bias_correction = (n_jack - 1.) $
                              * (original_estimate $
                                 - mean(jackknife_estimates))
      
      return, jackknife_std
  ENDIF ELSE IF size(reform(jackknife_estimates), /n_dimensions) EQ 2 $
  THEN BEGIN
      IF debug GE 2 THEN message, '2d array of values: covariance', /inf
      dims = size(jackknife_estimates, /dimensions)
      n_vars = dims[0]
      n_jack = dims[1]
      
      cov_mat = correlate(jackknife_estimates, /covariance)
      jackknife_cov_mat = (n_jack - 1.) * cov_mat $
                          * (n_jack - 1.) / n_jack

      IF arg_present(jackknife_mean) THEN $
         jackknife_mean = total(jackknife_estimates, 2) / float(n_jack)

      IF arg_present(bias_correction) $
         AND n_elements(original_estimate) GT 0 THEN $
            bias_correction = (n_jack - 1.) $
                              * (original_estimate $
                                 - (total(jackknife_estimates, 2) $
                                    / float(n_jack)))
      
      return, jackknife_cov_mat
  ENDIF

END

<span class="comments">;+</span>
<span class="comments">; Test ajs_jackknife</span>
<span class="comments">;-</span>
PRO ajs_jackknife_test
  compile_opt idl2

  <span class="comments">;; Random points from Gaussian</span>
  n_points = 10000               <span class="comments">; Multiple of 100</span>
  x = randomn(seed, n_points)
  indices = indgen(n_points)
  mean_x = mean(x)
  std_mean_x = sqrt(1. / n_points)
  print, 'Mean of', n_points, ' points drawn from N(0,1)'
  print, 'True mean:', mean_x
  print, 'Expected standard deviation on mean:', std_mean_x

  <span class="comments">;; Jackknife removing one point at a time</span>
  jackknife_estimates = fltarr(n_points)
  FOR i = 0L, n_points - 1 DO BEGIN
      jackknife_estimates[i] = mean(x[where(indices NE i)])
  ENDFOR
  jackknife_std = ajs_jackknife(jackknife_estimates, $
                                original_estimate=mean_x, $
                                bias_correction=bias_correction)
  print, 'Jackknife one point at a time:'
  print, '  Bias-corrected mean:', mean_x + bias_correction
  print, '  Jackknife standard deviation:', jackknife_std

  <span class="comments">;; Jackknife removing 1/100 of the points at a time</span>
  jackknife_estimates = fltarr(n_points / 100)
  FOR i = 0L, (n_points / 100) - 1 DO BEGIN
      jackknife_estimates[i] = mean(x[where(indices LT i * 100 $
                                            OR indices GE (i + 1) * 100)])
  ENDFOR
  jackknife_std = ajs_jackknife(jackknife_estimates, $
                                original_estimate=mean_x, $
                                bias_correction=bias_correction)
  print, '100 jackknife resamplings:'
  print, '  Bias-corrected mean:', mean_x + bias_correction
  print, '  Jackknife standard deviation:', jackknife_std

  <span class="comments">;; Jackknife removing 1/20 of the points at a time</span>
  jackknife_estimates = fltarr(n_points / 20)
  FOR i = 0L, (n_points / 20) - 1 DO BEGIN
      jackknife_estimates[i] = mean(x[where(indices LT i * 20 $
                                            OR indices GE (i + 1) * 20)])
  ENDFOR
  jackknife_std = ajs_jackknife(jackknife_estimates, $
                                original_estimate=mean_x, $
                                bias_correction=bias_correction)
  print, '20 jackknife resamplings:'
  print, '  Bias-corrected mean:', mean_x + bias_correction
  print, '  Jackknife standard deviation:', jackknife_std

END
</code>
    </div>
  </body>
</html>