<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.0 on Fri Jan 16 23:50:57 2009 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>ajs_vmax.pro (Anthony Smith's IDL routines)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="ajs_vmax.pro (Anthony Smith's IDL routines)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">; Calculate Vmax given galaxy data and limits</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; Return zminmax for magnitudes</span>
<span class="comments">;-</span>
FUNCTION ajs_vmax_zminmax_mag, z, dm_k, var, table_row
  compile_opt idl2, hidden
  debug = ajs_debug()

  <span class="comments">;; If array not monotonic, apply smoothing and hope that works</span>
  IF ~ ajs_is_monotonic(dm_k) THEN BEGIN
      FOR i = 2, 20 DO BEGIN
          IF ajs_is_monotonic(smooth(dm_k, i)) THEN BEGIN
              dm_k = smooth(dm_k, i)
              BREAK
          ENDIF
      ENDFOR
      IF debug GE 3 THEN BEGIN
          IF ajs_is_monotonic(dm_k) THEN $
             msg2 = 'smooth window = ' + strtrim(i, 2) $
          ELSE $
             msg2 = 'not fixed'
          message, 'Interpolation arr not monotonic: ' + msg2, /inf
      ENDIF
  ENDIF
  abs_value = table_row.(where(tag_names(table_row) $
                               EQ strupcase(var.abs_name)))
  IF var.app_min - abs_value LT min(dm_k) THEN $
     z1 = 0 $                   <span class="comments">; Outside interpolation range</span>
  ELSE $
     z1 = interpol(z, dm_k, var.app_min - abs_value, /quadratic)
  IF var.app_max - abs_value GT max(dm_k) THEN $
     z2 = !values.f_infinity $  <span class="comments">; Outside interpolation range</span>
  ELSE $
     z2 = interpol(z, dm_k, var.app_max - abs_value, /quadratic)
  IF debug GE 3 THEN BEGIN 
      z_interp = $
         interpol(z, dm_k, $
                  table_row.(where(tag_names(table_row) EQ $
                                   strupcase(var.app_name))) - abs_value, $
                  /quadratic)
      message, strjoin(strtrim([z_interp, z1, z2], 2), ' '), /inf
      IF var.band EQ 'K' THEN color = 0 ELSE color = 3
      oplot, [table_row.z], [z_interp], color=color, psym=3 <span class="comments">; black or green</span>
  ENDIF
  IF z2 LT 0 THEN stop
  return, [z1, z2]
END


<span class="comments">;+</span>
<span class="comments">; Return zminmax for surface brightness</span>
<span class="comments">;-</span>
FUNCTION ajs_vmax_zminmax_sb, z, kc, var, table_row
  compile_opt idl2, hidden
  COMMON debug_block, debug     <span class="comments">; 0 none, 1 basics, 2 verbose, 3 ridiculous</span>

  sb_dimming = 10 * alog10(1 + z) + kc
  IF debug GE 3 THEN IF NOT ajs_is_monotonic(sb_dimming) THEN $
     message, 'Interpolation array not monotonic', /inf

  abs_value = table_row.(where(tag_names(table_row) $
                               EQ strupcase(var.abs_name)))
  IF var.app_min - abs_value LT min(sb_dimming) THEN $
     z1 = 0 $                   <span class="comments">; Outside interpolation range</span>
  ELSE $
     z1 = interpol(z, sb_dimming, var.app_min - abs_value, /quadratic)
  IF var.app_max - abs_value GT max(sb_dimming) THEN $
     z2 = !values.f_infinity $  <span class="comments">; Outside interpolation range</span>
  ELSE $
     z2 = interpol(z, sb_dimming, var.app_max - abs_value, /quadratic)
  IF debug GE 3 THEN BEGIN 
      z_interp = $
         interpol(z, sb_dimming, $
                  table_row.(where(tag_names(table_row) EQ $
                                   strupcase(var.app_name))) - abs_value, $
                  /quadratic)
      message, strjoin(strtrim([z_interp, z1, z2], 2), ' '), /inf
<span class="comments">;;       message, $</span>
<span class="comments">;;          strtrim(z_interp, 2) $</span>
<span class="comments">;;          + ' ' + strtrim(table_row.(where(tag_names(table_row) EQ $</span>
<span class="comments">;;                                           strupcase(var.app_name))), 2) $</span>
<span class="comments">;;          + ' ' + strtrim(table_row.(where(tag_names(table_row) EQ $</span>
<span class="comments">;;                                           strupcase(var.abs_name))), 2), /inf</span>
      oplot, [table_row.z], [z_interp], color=1, psym=3 <span class="comments">; red</span>
  ENDIF
  return, [z1, z2]
END


<span class="comments">;+</span>
<span class="comments">; Return zminmax for radius</span>
<span class="comments">;-</span>
FUNCTION ajs_vmax_zminmax_rad, z, d_a, var, table_row
  compile_opt idl2, hidden
  COMMON debug_block, debug     <span class="comments">; 0 none, 1 basics, 2 verbose, 3 ridiculous</span>

  kpc_over_arcsec = !PI / 180 / 3600 * 1000 * d_a
  abs_value = table_row.(where(tag_names(table_row) $
                               EQ strupcase(var.abs_name)))
  IF debug GE 3 THEN IF NOT ajs_is_monotonic(kpc_over_arcsec) THEN $
     message, 'Interpolation array not monotonic', /inf
  IF abs_value / var.app_min LT min(kpc_over_arcsec) THEN $
     z1 = 0 $                   <span class="comments">; Outside interpolation range</span>
  ELSE $
     z1 = interpol(z, kpc_over_arcsec, abs_value / var.app_max, /quadratic)
  IF abs_value / var.app_max GT max(kpc_over_arcsec) THEN $
     z2 = !values.f_infinity $  <span class="comments">; Outside interpolation range</span>
  ELSE $
     z2 = interpol(z, kpc_over_arcsec, abs_value / var.app_min, /quadratic)
  IF debug GE 3 THEN BEGIN 
      z_interp = $
         interpol(z, kpc_over_arcsec, $
                  abs_value / table_row.(where(tag_names(table_row) EQ $
                                               strupcase(var.app_name))), $
                  /quadratic)
      message, strjoin(strtrim([z_interp, z1, z2], 2), ' '), /inf
      oplot, [table_row.z], [z_interp], color=2, psym=3 <span class="comments">; blue</span>
  ENDIF
  return, [z1, z2]
END

<span class="comments">;+</span>
<span class="comments">; Return the minimum and maximum redshifts at which the galaxy would</span>
<span class="comments">; be visible</span>
<span class="comments">;-</span>
FUNCTION ajs_vmax_zminmax, z, dm_k, kc, d_a, var, table_row
  compile_opt idl2, hidden
  COMMON debug_block, debug     <span class="comments">; 0 none, 1 basics, 2 verbose, 3 ridiculous</span>

  CASE var.type OF
      'M' : zminmax = ajs_vmax_zminmax_mag(z, dm_k, var, table_row)
      'S' : zminmax = ajs_vmax_zminmax_sb(z, kc, var, table_row)
      'R' : zminmax = ajs_vmax_zminmax_rad(z, d_a, var, table_row)
  ENDCASE

  return, zminmax
END


<span class="comments">;+</span>
<span class="comments">; Calculate Vmax given galaxy data and limits</span>
<span class="comments">; :Returns:</span>
<span class="comments">;    vmax: in h^-3 Mpc^3</span>
<span class="comments">; :Params:</span>
<span class="comments">;    table : in, required</span>
<span class="comments">;       Array of structures with fields {coeffs:, z:} and columns for absolute</span>
<span class="comments">;       values given in vars. Redshift z is optional: raises warning</span>
<span class="comments">;       if outside observable limits.</span>
<span class="comments">;    vars : in, required</span>
<span class="comments">;       Array of structures with fields {abs_name:} giving the column</span>
<span class="comments">;       name in table corresponding to the absolute value, {band:} giving the</span>
<span class="comments">;       name of the band, {type:} giving 'M'agnitudes, 'S'urface brightness</span>
<span class="comments">;       or 'R'adius and {app_min:, app_max:} giving the limits.</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    zmin : in, optional</span>
<span class="comments">;       Minimum redshift. Default = min(table.z) or 0</span>
<span class="comments">;    zmax : in, optional</span>
<span class="comments">;       Maximum redshift. Default = max(table.z) or 2</span>
<span class="comments">;    area : in, optional</span>
<span class="comments">;       Area of survey in square degrees. Default whole sky.</span>
<span class="comments">;    z_min_limited_by : out, optional</span>
<span class="comments">;       Number of galaxies with minimum redshift limited by each of</span>
<span class="comments">;       the variables, or by zmin</span>
<span class="comments">;    z_max_limited_by : out, optional</span>
<span class="comments">;       Number of galaxies with maximum redshift limited by each of</span>
<span class="comments">;       the variables, or by zmax</span>
<span class="comments">;    v : out, optional</span>
<span class="comments">;       Volume, as in V/Vmax, for each galaxy</span>
<span class="comments">; :History:</span>
<span class="comments">;    7 Mar 2008 Created, Anthony Smith</span>
<span class="comments">;</span>
<span class="comments">;    25 Jul 2008 Added v keyword (V/Vmax), AJS</span>
<span class="comments">;</span>
<span class="comments">;    8 Aug 2008 Doesn't attempt V/Vmax when table.z does not exist</span>
<span class="comments">;-</span>
FUNCTION ajs_vmax, table, vars, zmin=zmin, zmax=zmax, area=area, q0=q0, $
                   q1=q1, z_min_limited_by=z_min_limited_by, $
                   z_max_limited_by=z_max_limited_by, v=v
  compile_opt idl2, hidden
  COMMON debug_block, debug     <span class="comments">; 0 none, 1 basics, 2 verbose, 3 ridiculous</span>
  IF n_elements(debug) EQ 0 THEN debug = 0 
  IF debug GE 1 THEN BEGIN
      message, 'Calculating Vmax for galaxies', /inf
      message, ajs_kw_string(zmin=zmin, zmax=zmax, area=area, q0=q0, q1=q1), $
               /inf
  ENDIF
  IF n_elements(zmin) EQ 0 THEN $
     IF where(tag_names(table) EQ 'Z') NE -1 THEN $
        zmin = min(table.z) $
     ELSE $
        zmin = 0
  IF n_elements(zmax) EQ 0 THEN $
     IF where(tag_names(table) EQ 'Z') NE -1 THEN $
        zmax = max(table.z) $
     ELSE $
        zmax = 2
  IF n_elements(area) EQ 0 THEN $
     area_frac = 1 $
  ELSE $
     area_frac = double(area) / (360L ^ 2 / !PI)
  
  <span class="comments">;; Calculate K-correction for each galaxy at each of a range of redshifts</span>
  vmax = dblarr(n_elements(table))
  v = dblarr(n_elements(table))
  z = ajs_linspace(zmin, zmax, 201) <span class="comments">; or more - 2001?</span>
  z_min_limited_by = lonarr(n_elements(vars) + 1)
  z_max_limited_by = lonarr(n_elements(vars) + 1) 
  d_a = ajs_angdidis(double(z))
  dm = ajs_distmod(double(z))
  IF n_elements(q0) GT 0 THEN BEGIN
      q0_k = q0[8]
      q0_r = q0[2]
  ENDIF
  IF n_elements(q1) GT 0 THEN BEGIN
      q1_k = q1[8]
      q1_r = q1[2]
  ENDIF

  <span class="comments">;; Lump all the K-corrections together, if not too many (1e7 too many)</span>
  do_it_the_slow_way = n_elements(z) * n_elements(table) GT 8e6
  IF NOT do_it_the_slow_way THEN BEGIN
      IF debug GE 2 THEN message, 'Lumping K-corrections together', /inf
      z_all = reform(rebin(z, n_elements(z), n_elements(table)), $
                     n_elements(z) * n_elements(table))
      coeffs_all = rebin(table.coeffs, n_elements(table[0].coeffs), $
                         n_elements(table) * n_elements(z)) 
      IF debug GE 2 THEN message, 'Made z_all and coeffs_all', /inf
      dm_k_all_k = reform(ajs_dm_k(z_all, q0=q0_k, q1=q1_k, $
                                   coeffs=coeffs_all, band='K', $
                                   rmatrix=rmatrix_k, zvals=zvals_k, /nodm), $
                          n_elements(z), n_elements(table))
      dm_k_all_r = reform(ajs_dm_k(z_all, q0=q0_r, q1=q1_r, $
                                   coeffs=coeffs_all, band='r', $
                                   rmatrix=rmatrix_r, zvals=zvals_r, /nodm), $
                          n_elements(z), n_elements(table))
      z_all = 0                 <span class="comments">; Free memory</span>
      coeffs_all = 0
      IF debug GE 1 THEN message, 'Finished setting up K-corrections', /inf
  ENDIF ELSE $
     IF debug GE 2 THEN message, 'K-corrections one by one', /inf

  IF debug GE 3 THEN BEGIN
      plot, [zmin, zmax], [zmin, zmax], /nodata
      oplot, [zmin, zmax], [zmin, zmax], color=5
  ENDIF
  FOR i = 0L, n_elements(table) - 1 DO BEGIN
      IF debug GE 3 THEN message, strtrim(i, 2), /inf
      z1 = dblarr(n_elements(vars)) 
      z2 = dblarr(n_elements(vars))
      IF debug GE 3 THEN message, 'Galaxy ' + strtrim(i, 2) $
                                  + ' True redshift ' $
                                  + strtrim(table[i].z, 2), /inf
      FOR j = 0, n_elements(vars) - 1 DO BEGIN
          IF vars[j].band EQ 'K' THEN BEGIN
              IF do_it_the_slow_way THEN $
                 kc = ajs_dm_k(z, q0=q0_k, q1=q1_k, coeffs=table[i].coeffs, $
                               band='K', rmatrix=rmatrix_k, zvals=zvals_k, $
                               /nodm) $
              ELSE $
                 kc = dm_k_all_k[*, i]
              dm_k = kc + dm
          ENDIF ELSE IF vars[j].band EQ 'r' THEN BEGIN
              IF do_it_the_slow_way THEN $
                 kc = ajs_dm_k(z, q0=q0_r, q1=q1_r, coeffs=table[i].coeffs, $
                               band='r', rmatrix=rmatrix_r, zvals=zvals_r, $
                               /nodm) $
              ELSE $
                 kc = dm_k_all_r[*, i]
              dm_k = kc + dm
          ENDIF

          zminmax = ajs_vmax_zminmax(z, dm_k, kc, d_a, vars[j], table[i])
          z1[j] = zminmax[0]
          z2[j] = zminmax[1]
      ENDFOR
      z1 = max([z1, zmin], z1_subs)
      z2 = min([z2, zmax], z2_subs)
      IF where(tag_names(table) EQ 'Z') NE -1 THEN $
         IF (z1 GT table[i].z * 1.01 OR z2 LT table[i].z / 1.01) THEN BEGIN
          message, 'Galaxy ' + strtrim(i, 2) + ' should not be visible!', /inf
          message, 'z1 = ' + strtrim(z1, 2) + ', z2 = ' + strtrim(z2, 2) $
                   + ', z = ' + strtrim(table[i].z, 2) $
                   + ' [' + strtrim(z1_subs, 2) $
                   + ',' + strtrim(z2_subs, 2) + ']', /inf
      ENDIF
      IF z1 GT z2 THEN BEGIN
          IF debug GE 3 THEN message, 'Vmax = 0 for galaxy ' + strtrim(i, 2), $
                                      /inf
          z1 = z2
      ENDIF ELSE BEGIN
          <span class="comments">;; Which limit provided zmin and zmax?</span>
          z_min_limited_by[z1_subs]++
          z_max_limited_by[z2_subs]++
      ENDELSE
      vmax[i] = 4 * !PI / 3 * (lf_comvol(z2) - lf_comvol(z1)) * area_frac
      IF where(tag_names(table) EQ 'Z') NE -1 THEN $
         v[i] = 4 * !PI / 3 $
                * (lf_comvol(table[i].z) - lf_comvol(z1)) * area_frac
  ENDFOR 

  return, vmax
END

</code>
    </div>
  </body>
</html>