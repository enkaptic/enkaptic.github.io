<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.0 on Fri Jan 16 23:50:57 2009 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>ajs_vmax_bbd.pro (Anthony Smith's IDL routines)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="ajs_vmax_bbd.pro (Anthony Smith's IDL routines)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">; This procedure calculates the 1/Vmax bivariate brightness</span>
<span class="comments">; distribution from input arrays of two quantities (e.g., absolute</span>
<span class="comments">; magnitude and surface brightness) and weights (e.g., 1/Vmax)</span>
<span class="comments">;-</span>


<span class="comments">;+</span>
<span class="comments">; This procedure calculates the 1/Vmax bivariate brightness</span>
<span class="comments">; distribution from input arrays of two quantities (e.g., absolute</span>
<span class="comments">; magnitude and surface brightness) and weights (e.g., 1/Vmax)</span>
<span class="comments">;</span>
<span class="comments">; Bins in each dimension must have equal width</span>
<span class="comments">;</span>
<span class="comments">; :Returns: fltarr/dblarr</span>
<span class="comments">;    Returns phi, value of space density</span>
<span class="comments">; :Params:</span>
<span class="comments">;    m1 : in, required</span>
<span class="comments">;    m2 : in, required</span>
<span class="comments">;    weights : in, optional</span>
<span class="comments">;       E.g., 1./Vmax. Set to single value to give all galaxies the</span>
<span class="comments">;       same weight, or leave empty to give all galaxies a weight of 1.</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    bincentres1 : in, out, optional</span>
<span class="comments">;       Centre of each bin in m1</span>
<span class="comments">;    bincentres2 : in, out, optional</span>
<span class="comments">;       Centre of each bin in m2</span>
<span class="comments">;    err_phi : out, optional</span>
<span class="comments">;       Poisson errors = phi / sqrt(n)</span>
<span class="comments">;    ninbin : out, optional</span>
<span class="comments">;       Number of galaxies in each bin</span>
<span class="comments">;    nbins1 : in, optional</span>
<span class="comments">;       Number of bins in m1 (ignored if bincentres set)</span>
<span class="comments">;    nbins2 : in, optional</span>
<span class="comments">;       Number of bins in m2 (ignored if bincentres set)</span>
<span class="comments">;    xrange : in, optional</span>
<span class="comments">;       Minimum and maximum m1 (ignored if bincentres1 set)</span>
<span class="comments">;    yrange : in, optional</span>
<span class="comments">;       Minimum and maximum m2 (ignored if bincentres2 set)</span>
<span class="comments">;    jackknife : in, optional</span>
<span class="comments">;       Integer for each galaxy giving the jackknife region in which</span>
<span class="comments">;       the galaxy lies</span>
<span class="comments">;    choloniewski : in, out, optional</span>
<span class="comments">;       Choloniewski fit</span>
<span class="comments">;    chol_xrange : in, optional, type=fltarr(2)</span>
<span class="comments">;       xrange for Choloniewski fit (ajs_choloniewski_fit)</span>
<span class="comments">;    chol_yrange : in, optional, type=fltarr(2)</span>
<span class="comments">;       yrange for Choloniewski fit (ajs_choloniewski_fit)</span>
<span class="comments">;    cov_mat : out, optional</span>
<span class="comments">;       Covariance matrix of Choloniewski fit</span>
<span class="comments">;    vars : in, optional</span>
<span class="comments">;       See ajs_choloniewski_fit</span>
<span class="comments">;    zmin : in, optional</span>
<span class="comments">;       See ajs_choloniewski_fit</span>
<span class="comments">;    zmax : in, optional</span>
<span class="comments">;       See ajs_choloniewski_fit</span>
<span class="comments">;    area : in, optional</span>
<span class="comments">;       See ajs_choloniewski_fit</span>
<span class="comments">;    q0 : in, optional</span>
<span class="comments">;       See ajs_choloniewski_fit</span>
<span class="comments">;    q1 : in, optional</span>
<span class="comments">;       See ajs_choloniewski_fit</span>
<span class="comments">; :History:</span>
<span class="comments">;    6 Mar 2008 Created (Anthony Smith)</span>
<span class="comments">;</span>
<span class="comments">;    18 Mar 2008 Added jackknife</span>
<span class="comments">;</span>
<span class="comments">;    7 Apr 2008 Added jackknife Choloniewski fit</span>
<span class="comments">;-</span>
FUNCTION ajs_vmax_bbd, m1, m2, weights, bincentres1=bincentres1, $
                       bincentres2=bincentres2, $
                       err_phi=err_phi, ninbin=ninbin, nbins1=nbins1, $
                       nbins2=nbins2, xrange=xrange, yrange=yrange, $
                       jackknife=jackknife, $
                       choloniewski=choloniewski, chol_xrange=chol_xrange, $
                       chol_yrange=chol_yrange, cov_mat=cov_mat, $
                       vars=vars, zmin=zmin, zmax=zmax, area=area, q0=q0, q1=q1

  compile_opt idl2
  debug = ajs_debug()
  IF debug GE 1 THEN BEGIN
      message, 'Estimating 1/Vmax BBD', /inf
      message, ajs_kw_string(nbins1=nbins1, nbins2=nbins2, xrange=xrange, $
                             yrange=yrange, choloniewski=choloniewski, $
                             chol_xrange=chol_xrange, $
                             chol_yrange=chol_yrange, $
                             zmin=zmin, zmax=zmax, area=area, q0=q0, q1=q1), $
               /inf
  ENDIF

  <span class="comments">;; Preliminaries</span>
  IF n_elements(weights) EQ 1 THEN $
     weights = replicate(weights, n_elements(m1)) $ 
  ELSE IF n_elements(weights) EQ 0 THEN $
     weights = replicate(1, n_elements(m1))
  IF n_elements(bincentres1) EQ 0 THEN BEGIN
      IF n_elements(nbins1) EQ 0 THEN $
         nbins1 = 24
      IF n_elements(xrange) GT 0 THEN $
<span class="comments">;;          bincentres1 = ajs_linspace(max([min(xrange), min(m1)]), $</span>
<span class="comments">;;                                     min([max(xrange), max(m1) + 1d-5]), $</span>
         bincentres1 = ajs_linspace(min(xrange), max(xrange), $
                                    nbins1, $
                                    /bincentres) $
      ELSE $
         bincentres1 = ajs_linspace(min(m1), max(m1) + 1e-6, nbins1, $
                                    /bincentres)
  ENDIF
  IF n_elements(bincentres2) EQ 0 THEN BEGIN
      IF n_elements(nbins2) EQ 0 THEN $
         nbins2 = 24
      IF n_elements(yrange) GT 0 THEN $
<span class="comments">;;          bincentres2 = ajs_linspace(max([min(yrange), min(m2)]), $</span>
<span class="comments">;;                                     min([max(yrange), max(m2) + 1d-5]), $</span>
         bincentres2 = ajs_linspace(min(yrange), max(yrange), $
                                    nbins2, $
                                    /bincentres) $
      ELSE $
         bincentres2 = ajs_linspace(min(m2), max(m2) + 1d-5, nbins2, $
                                    /bincentres)
  ENDIF
  binsize1 = (max(bincentres1) - min(bincentres1)) $
             / (n_elements(bincentres1) - 1)
  m1_min = min(bincentres1) - binsize1 / 2.
  m1_max = max(bincentres1) + binsize1 / 2. - 1d-5
  binsize2 = (max(bincentres2) - min(bincentres2)) $
             / (n_elements(bincentres2) - 1)
  m2_min = min(bincentres2) - binsize2 / 2.
  m2_max = max(bincentres2) + binsize2 / 2. - 1d-5

  <span class="comments">;; Do the whole thing whether or not jackknife is going to be done</span>
  incl = where(m1 GE m1_min AND m1 LE m1_max $
               AND m2 GT m2_min AND m2 LE m2_max)
  phi = hist2d(m1[incl], m2[incl], weights[incl], $
               min1=m1_min, max1=m1_max, $
               binsize1=binsize1, obin1=obin1, omin1=omin1, omax1=omax1, $
               min2=m2_min, max2=m2_max, $
               binsize2=binsize2, obin2=obin2, omin2=omin2, omax2=omax2, $
               density=ninbin) / binsize1 / binsize2
  err_phi = phi / sqrt(ninbin)
  IF arg_present(choloniewski) THEN BEGIN
      choloniewski = ajs_choloniewski_fit(bincentres1, bincentres2, $
                                          phi, err_phi, $
                                          xrange=chol_xrange, $
                                          yrange=chol_yrange, vars=vars, $
                                          zmin=zmin, zmax=zmax, area=area, $
                                          q0=q0, q1=q1, cov_mat=cov_mat)
  ENDIF

  <span class="comments">;; Check okay</span>
  IF n_elements(obin1) NE n_elements(bincentres1) $
     OR n_elements(obin2) NE n_elements(bincentres2) THEN $
     message, 'Conflicting bins'
  IF total(ninbin) NE n_elements(incl) THEN $
     message, 'Different total number after making histogram'

  IF n_elements(jackknife) GT 0 THEN BEGIN
      IF debug GE 1 THEN message, 'Using jackknife resampling', /inf

      <span class="comments">;; Original (full) sample</span>
      phi_orig = phi
      err_phi_orig = err_phi
      ninbin_orig = ninbin
      IF arg_present(choloniewski) THEN $
         choloniewski_orig = choloniewski
      
      <span class="comments">;; Prepare for jackknife resampling</span>
      min_jack = min(jackknife)
      n_jack = max(jackknife) - min_jack + 1
      phi_arr = dblarr(n_elements(bincentres1), n_elements(bincentres2), $
                       n_jack)
      ninbin_arr = dblarr(n_elements(bincentres1), n_elements(bincentres2), $
                          n_jack)
      IF arg_present(choloniewski) THEN $
         choloniewski_arr = dblarr(6, n_jack)

      <span class="comments">;; Results excluding each jackknife sample in turn</span>
      FOR i = 0, n_jack - 1 DO BEGIN
          IF debug GE 2 THEN message, 'Jackknife ' + string(i), /inf
          incl = where(m1 GE m1_min AND m1 LE m1_max $
                       AND m2 GT m2_min AND m2 LE m2_max $
                       AND jackknife NE i + min_jack, n_current)
          phi_arr[*, *, i] = $
             hist2d(m1[incl], m2[incl], weights[incl], $
                    min1=m1_min, max1=m1_max, $
                    binsize1=binsize1, obin1=obin1, omin1=omin1, omax1=omax1, $
                    min2=m2_min, max2=m2_max, $
                    binsize2=binsize2, obin2=obin2, omin2=omin2, omax2=omax2, $
                    density=ninbin) / binsize1 / binsize2 $
             <span class="comments">;; NB weights adjusted according to no. of galaxies</span>
             <span class="comments">;; If equal area: * n_jack / (n_jack - 1)</span>
             * n_elements(m1) / n_current
          <span class="comments">;; NB original err_phi may have been altered by chol. fit to</span>
          <span class="comments">;; supply values for empty bins: don't want to do</span>
          <span class="comments">;; that every time!</span>
          err_phi_tmp = phi_arr[*, *, i] / sqrt(ninbin)
          no_err = where(err_phi_tmp LE 0 OR finite(err_phi_tmp, /nan), $
                         n_no_err)
          IF n_no_err GT 0 THEN $
             err_phi_tmp[no_err] = err_phi_orig[no_err] $
                                   * sqrt(total(ninbin_orig) / total(ninbin))
          ninbin_arr[*, *, i] = ninbin
          IF arg_present(choloniewski) THEN BEGIN
              choloniewski_arr[*, i] = $
                 ajs_choloniewski_fit(bincentres1, bincentres2, $
                                      phi_arr[*, *, i], err_phi_tmp, $
                                      xrange=chol_xrange, $
                                      yrange=chol_yrange, vars=vars, $
                                      zmin=zmin, zmax=zmax, area=area, $
                                      q0=q0, q1=q1)
          ENDIF
      ENDFOR

      <span class="comments">;; Jackknife quantities</span>
      phi = dblarr(n_elements(bincentres1), n_elements(bincentres2))
      err_phi = dblarr(n_elements(bincentres1), n_elements(bincentres2))
      FOR i = 0, n_elements(bincentres1) - 1 DO BEGIN
          FOR j = 0, n_elements(bincentres2) - 1 DO BEGIN
              err_phi[i, j] = ajs_jackknife(phi_arr[i, j, *], $
                                            bias_correction=bc_tmp, $
                                            original_estimate=phi_orig[i, j])
              phi[i, j] = phi_orig[i, j] + bc_tmp
<span class="comments">;;               err_phi[i, j] = ajs_jackknife(phi_arr[i, j, *], $</span>
<span class="comments">;;                                             jackknife_mean=phi_tmp)</span>
<span class="comments">;;               phi[i, j] = phi_tmp</span>
          ENDFOR
          <span class="comments">;; No zero errors</span>
          zeros = where(err_phi EQ 0, n_zeros)
          IF n_zeros GT 0 THEN $
             err_phi[zeros] = err_phi_orig[zeros]
      ENDFOR

      IF arg_present(choloniewski) THEN BEGIN
          choloniewski = dblarr(6)
          cov_mat = ajs_jackknife(choloniewski_arr, bias_correction=bc_tmp, $
                                  original_estimate=choloniewski_orig)
          choloniewski = choloniewski_orig + bc_tmp
      ENDIF
      
      <span class="comments">;; Number in each bin (no jackknife)</span>
      ninbin = ninbin_orig
<span class="comments">;;       incl = where(m1 GE m1_min AND m1 LE m1_max $</span>
<span class="comments">;;                    AND m2 GT m2_min AND m2 LE m2_max)</span>
<span class="comments">;;       ninbin = $</span>
<span class="comments">;;          hist2d(m1[incl], m2[incl], $</span>
<span class="comments">;;                 min1=m1_min, max1=m1_max, $</span>
<span class="comments">;;                 binsize1=binsize1, obin1=obin1, omin1=omin1, omax1=omax1, $</span>
<span class="comments">;;                 min2=m2_min, max2=m2_max, $</span>
<span class="comments">;;                 binsize2=binsize2, obin2=obin2, omin2=omin2, omax2=omax2)</span>
  ENDIF <span class="comments">;ELSE BEGIN</span>
<span class="comments">;;       incl = where(m1 GE m1_min AND m1 LE m1_max $</span>
<span class="comments">;;                    AND m2 GT m2_min AND m2 LE m2_max)</span>
<span class="comments">;;       phi = hist2d(m1[incl], m2[incl], weights[incl], $</span>
<span class="comments">;;                    min1=m1_min, max1=m1_max, $</span>
<span class="comments">;;                    binsize1=binsize1, obin1=obin1, omin1=omin1, omax1=omax1, $</span>
<span class="comments">;;                    min2=m2_min, max2=m2_max, $</span>
<span class="comments">;;                    binsize2=binsize2, obin2=obin2, omin2=omin2, omax2=omax2, $</span>
<span class="comments">;;                    density=ninbin) / binsize1 / binsize2</span>
<span class="comments">;;       err_phi = phi / sqrt(ninbin)</span>
<span class="comments">;;   ENDELSE</span>

  IF debug GE 1 THEN $
     message, 'Total number of galaxies: ' + strtrim(total(ninbin), 2), /inf

<span class="comments">;;   empty_bins = where(ninbin EQ 0, nempty)</span>
<span class="comments">;;   IF nempty GT 0 THEN BEGIN</span>
<span class="comments">;;       phi[empty_bins] = 0</span>
<span class="comments">;;       err_phi[empty_bins] = !values.f_nan</span>
<span class="comments">;;   ENDIF</span>

  return, phi
END


<span class="comments">;+</span>
<span class="comments">; Test ajs_vmax_lf</span>
<span class="comments">;-</span>
PRO ajs_vmax_bbd_test
  compile_opt idl2

  m1 = ajs_linspace(-26, -16, 50)
  m2 = ajs_linspace(14, 24, 50)
  weights = intarr(n_elements(m1)) + 1e-6 
  phi = ajs_vmax_bbd(m1, m2, weights, nbins1=30, nbins2=30, ninbin=ninbin)
  print, phi
  print, total(ninbin)

END
</code>
    </div>
  </body>
</html>